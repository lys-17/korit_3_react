1. CRUD - back-front 연결 / CORS 처리
2. SpringBoot Security 적용하고 CRUD 연결
3. 오류로 인해 2번으로 default 로그인 창 / CRUD연결
4. OAuth2 연결
  - Google을 통해서 로그인을 할 것이므로 인증 받는 과정


- src 내부에 config 패키지 생성 → SecurityConfig.java

```java
package com.example.todo_backend_mariadb.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authz ->
                        // preflight 요청(OPTION 매서드)은 인증 없이 모두 허용
                        authz.requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
                                // 현재 로그인 기능이 바로 없으므로, 모든 API 요청을 임시로 허용
                                .requestMatchers("/api/**").permitAll()
                                // 혹시 몰라서 나머지 모든 요청도 일단 허용
                                .anyRequest().permitAll()
                );
        return http.build();
    }
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Cache-Control", "Content-Type"));
        configuration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```
- 이상과 같이 작성 → 근데 filterChain은 필수적으로 요구되기 때문에 복습 및 연구 요구

- application.properties 확인
  - 백엔드에서 데이터를 생성(POST)하거나 수정(PUT/PATCH)했을 때, 그 결과를 프론트엔드에게 알려주도록 설정. 만약에 이 부분이 빠지게되면 프론트엔드는 백에서 생성된 데이터의 id를 알 수 없기 때문에 이후에 충돌이 일어날 가능성이 있음.

```application.properties
spring.data.rest.return-body-on-create=true
spring.data.rest.return-body-on-update=true
```
- 재시작을 했을 때 정상적으로 실행이 된다면 일단 모든 HTTP 메서드 요청에 대한 허용이 적용되어있는 백엔드가 작성됐다고 볼 수 있음.
- 수정된 백엔드를 기반으로 React 프로젝트를 백엔드와 연결하는 과정이 필요한데, 기존에 만들어 놨던 (즉 프론트 상에서 구현이 되는 것을 확인했던) 부분들을 백엔드의 연결과 맞게 뜯어고쳐야함.
- 이상의 과정에서 느끼기 쉬운 부분이 → 고칠 것인데 애ㅗ 만들었냐고 할 수 있지만 구형 자체를 가능하게 만들어 놓고 백과 연결하기 위해서라고 생각하면 됨.
```tsx
import './App.css'
import { useState } from 'react';
import type { Todo } from './types/Todo';
import TodoForm from "./components/TodoForm"
import {TodoList} from "./components/TodoList"
import { v4 as uuid } from 'uuid';

function App() {
  const [ todos, setTodos ] = useState<Todo[]>(() => {
    const storedTodos = localStorage.getItem('todos');
    return storedTodos ? JSON.parse(storedTodos): [];
  });

  const addTodo = (text: string) => {
    const newTodo: Todo = {
      id: uuid(),
      text,
      completed: false,
    }
    const updatedTodos = [ ...todos, newTodo ];
    console.log('updatedTodos --->', updatedTodos);
    setTodos(updatedTodos);
    localStorage.setItem('todos', JSON.stringify(updatedTodos));
  }

  const deleteTodo = (id: string) => {
    const updatedTodos = todos.filter((todo) => todo.id !== id);
    setTodos(updatedTodos);
    localStorage.setItem('todos', JSON.stringify(updatedTodos));
  } 

  const toggleComplete = (id: string) => {
    const updatedTodos = todos.map((todo) => todo.id === id ? {...todo, completed: !todo.completed } : todo );
    setTodos(updatedTodos);
    localStorage.setItem('todos', JSON.stringify(updatedTodos));
  }

  return (
    <div>
      <h1>쇼핑 리스트</h1>
      <TodoForm onAddTodo={addTodo}/>
      <TodoList todos={todos} onToggleComplete={toggleComplete} onDeleteTodo={deleteTodo}/>
    </div>
  )
}

export default App
```
- 수정 전 마지막 프론트 자체만으로 굴러가던 프론트를 붙여놓음

이제 수정할건데, 첫 번째 -> types.ts에서 id: number로 수정

- src 내부에 services 폴더 생성 -> todoService.ts 파일 생성
- 백-프론트 연결이 기준이 됨.
  - 백에서 정보를 받아와서 프론트에서 보여주거나,
  - 프론트에 입력한 정보를 백에 POST / PUT / PATCH / DELETE가 일어나야함.(npm install axios)

# HATEOAS
## 정의
REST 아키텍쳐의 중요한 제약 조건 중 하나로, 애플리케이션 상태가 하이퍼미디어(링크)를 통해 전이되고 결정되는 방식을 의미
즉, 클라이언트가 서버로부터 받은 응답에 포함된 링크들을 통해 다음에 수행할 수 있는 동작을 동적으로 파악할 수 있게끔 하고, API와 상호작용하도록 하는 메커니즘

## 핵심 개념
기존의 REST API의 경우에는 클라이언트가 특정 기능을 수행하기 위해서는 필요한 URI를 미리 알고 하드코딩을 해야 했음. 예를 들어 사용자 정보를 조회한 후에 해당 사용자를 수정하려면 `/users/{id}`와 같은 URI를 클라이언트 개발자가 직접 알고 구성해야했음. 

근데 HATEOAS를 적용한 API응 응답 데이터에 관련된 다른 라소스에 접근할 수 있는 링크가 애초에 포함되어 있음. 이 링크들은 `rel`(relation) 속성을 통해 어떤 종류의 동작인지 설명하며, `href` 속성으로 해당 동작을 수행할 수 있는 URI를 명시해줌

```json

```















































## 장점

## 단점




# URL vs. URI
URL(Uniform Resource Locator)
URI(Uniform Resource Identifier)
로, 웹에서 자원(resource)을 나타내는 문자열이라는 측면에서 유사함.
URI가 URL을 포함하는 상위 개념.

URI의 경우에는 고유한 식별이 가능하기만 하면 되는 반면, URL은 규막(프로토콜(http 등))


# 과제
postman에서 데이터 집어넣을 것
- App.tsx 파일 완성하기 

postman에서 POST 요청을 넣고 URl을 적절하게 입력하고 / POST 요청 해두고 / data - raw - JSON 형태로 그리고 JSON 형태로 데이터를 입력해야 함.

```json
{
    "text": "어쩌고",
    "completed": false
}
```
해서 send 보냈을 때 200 ok가 뜨면 성공







이상의 코드로 axios를 활용, 백엔드로부터 데이터를 생성/읽기/수정/삭제하는 함수들을 작성. 이 다음은 받아온 데이터들을 가지고 App.tsx에서 어떻게 조작하는 가와 관련이 있음.

현재 App.tsx의 경우에는 useEffect를 추가한 것 이외에 addTodo,deleteTodo